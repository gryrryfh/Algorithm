6문제 나온다함  
  
알고리즘 수도코드 문제 나옴  

정리
## 1장 알고리즘 설계와 분석의 기초
알고리즘이란? 문제 해결 절차를 체계적으로 기술한 것 알고리즘은 입력으로부터 출력을 만드는 과정을 기술  
문제의 요구조건 : 입력과 출력으로 명시할 수 있다  
알고리즘 공부의 목적 : 특정한 문제를 위한 알고리즘의 습득, 지적추상화 레벨 상승  
바람직한 알고리즘 : 명확해야한다, 효율적이어야 한다.  
알고리즘의 수행시간 : 루프, 홤수 호출, 반복 등이 수행시간을 좌우한다  
재귀적 사고 : 자기호출(recursion) 어떤 문제 안에 크기만 다를 뿐 성격이 똑같은 작은 ㅁ누제들이 포함되어 있는 것  
재귀적 사고의 예시 : 팩토리얼(factorial), 수열의 점화식(an=an-1 +2), 병합정렬  
알고리즘의 적용 주제 : 카 네비게이션, 스케쥴링, 인간게놈프로젝트, 자원의 배치 , 반도체 설계  
알고리즘 분석 이유 : 무결성 확인, 자원 효율성 파악(시간, 메모리 등)  
알고리즘 분석  
1) 크기가 작은 문제 : 알고리즘의 효율성이 중요하지 않다. 비효율적인 알고리즘도 무방  
2) 크기가 큰 문제 : 알고리즘의 효율성이 중요하다. 비효율적인 알고리즘은 치명적  
점근적 분석 : 입력의 크기가 충분히 큰 경우에 대한 분석   
점근적 분석 표기법 : 빅오, 리틀오, 오메가, 리틀오메가,세타 최대한  타이트하게 (상수 비율의 차이는 무시)   
빅오 : 기것해야 함수의 비율로 증가하는 함수(함수보다 빠르게 증가하지 않는다)(Tight or loose upper bound)  
오메가 : 적어도 함수의 비율로 증가하는 함수(함수보다 느리게 증가하지 않는다)(Tight or loose lower bound)  
세타 : 함수의 비율로 증가하는 함수(함수와 같은 정도로 증가한다)(tight bound)  
리틀오 :  
리틀오메가 :  
점근적 복잡도의 예시 : 선택정렬(세타(n제곱)) 힙정렬(O(nlogn)), 퀵정렬(O(n제곱)), 평균(세타(nlogn))  
시간 복잡도 분석 : Worst-case, Average-case, Best-case(유용하지 않음)  
저장, 검색의 복잡도 : 배열 O(n) Binary search trees 최악의 경우 세타(n) 평균 세타(logn)  
 Balanced binary search trees 최악의 경우 세타(logn) B-tree 최악의 경우 세타(logn) Hash table 평균 세타(1)  
크기가 n인 배열에서 원소 찾기 : Sequential search(배열이 아무렇게나 저장되어 있을 때) worst case :세타(n) average case : 세타(n)  
Binary search(배열이 정렬되어 있을 때) Worst case : 세타(logn) Average case : 세타(logn)  
  
## 2장 점화식과 점근적 복잡도 분석

## 정렬 알고리즘 수도코드
