6문제 나온다함  
  
알고리즘 수도코드 문제 나옴  

정리
## 1장 알고리즘 설계와 분석의 기초
알고리즘이란? 문제 해결 절차를 체계적으로 기술한 것 알고리즘은 입력으로부터 출력을 만드는 과정을 기술  
문제의 요구조건 : 입력과 출력으로 명시할 수 있다  
알고리즘 공부의 목적 : 특정한 문제를 위한 알고리즘의 습득, 지적추상화 레벨 상승  
바람직한 알고리즘 : 명확해야한다, 효율적이어야 한다.  
알고리즘의 수행시간 : 루프, 홤수 호출, 반복 등이 수행시간을 좌우한다  
재귀적 사고 : 자기호출(recursion) 어떤 문제 안에 크기만 다를 뿐 성격이 똑같은 작은 ㅁ누제들이 포함되어 있는 것  
재귀적 사고의 예시 : 팩토리얼(factorial), 수열의 점화식(an=an-1 +2), 병합정렬  
알고리즘의 적용 주제 : 카 네비게이션, 스케쥴링, 인간게놈프로젝트, 자원의 배치 , 반도체 설계  
알고리즘 분석 이유 : 무결성 확인, 자원 효율성 파악(시간, 메모리 등)  
알고리즘 분석  
1) 크기가 작은 문제 : 알고리즘의 효율성이 중요하지 않다. 비효율적인 알고리즘도 무방  
2) 크기가 큰 문제 : 알고리즘의 효율성이 중요하다. 비효율적인 알고리즘은 치명적  
점근적 분석 : 입력의 크기가 충분히 큰 경우에 대한 분석   
점근적 분석 표기법 : 빅오, 리틀오, 오메가, 리틀오메가,세타 최대한  타이트하게 (상수 비율의 차이는 무시)   
빅오 : 기것해야 함수의 비율로 증가하는 함수(함수보다 빠르게 증가하지 않는다)(Tight or loose upper bound)  
오메가 : 적어도 함수의 비율로 증가하는 함수(함수보다 느리게 증가하지 않는다)(Tight or loose lower bound)  
세타 : 함수의 비율로 증가하는 함수(함수와 같은 정도로 증가한다)(tight bound)  
리틀오 :  
리틀오메가 :  
점근적 복잡도의 예시 : 선택정렬(세타(n제곱)) 힙정렬(O(nlogn)), 퀵정렬(O(n제곱)), 평균(세타(nlogn))  
시간 복잡도 분석 : Worst-case, Average-case, Best-case(유용하지 않음)  
저장, 검색의 복잡도 : 배열 O(n) Binary search trees 최악의 경우 세타(n) 평균 세타(logn)  
 Balanced binary search trees 최악의 경우 세타(logn) B-tree 최악의 경우 세타(logn) Hash table 평균 세타(1)  
크기가 n인 배열에서 원소 찾기 : Sequential search(배열이 아무렇게나 저장되어 있을 때) worst case :세타(n) average case : 세타(n)  
Binary search(배열이 정렬되어 있을 때) Worst case : 세타(logn) Average case : 세타(logn)  
  
## 2장 점화식과 점근적 복잡도 분석
점화식 : 어떤 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것 ex) an=an-1 +2  
점화식의 점근적 분석 방법  
1. 반복대치 : 더 작은 문제에 대한 함수로 반복해서 대치해 나가는 해법 ex)펙토리얼  
   반복대치의 과정 :  
3. 추정후 증명 : 결론을 추정하고 수학적 귀납법으로 이용하여 증명하는 방법  
   추정후 증명의 과정 :   
5. 마스터 정리 : 형식에 맞는 점화식의 복잡도를 바로 알 수 있다     
   마스터 정리의 과정 :  
## 3장 정렬  

기초정렬
  
정렬 알고리즘 : 대부분 O(n^2)과 O(nlogn)사이 특수한 성질을 만족하는 경우 O(n)정렬도 가능  .
  
원시 정렬 알고리즘 : 알고리즘을 보는 시각 -flow 중심 관계 중심  
기초 정렬 알고리즘 : 선택정렬, 버블정렬, 삽입정렬 (평균 세타(n^2)소요)  
  
선택정렬 : 각 루프마다 최대 원소를 찾고 최대원소와 맨 오른쪽 원소를 교환, 맨 오른쪽 원소를 제외 하나의 원소만 남을 때까지 위의 루프를 반복  
수행시간 : O(n^2)=worst case = Average case 
  
버블 정렬 : 왼쪽부터 이웃한 쌍을 비교 큰게 왼쪽으로 루프 끝까지 하고 맨왼쪽꺼(가장 큰거) 제외 또 처음부터 시작 또 순서대로 되어있찌 않은거 자리 바꾸고 루프 끝까지 반복    
수행시간 : 세타(n^2)=worstcase=average case  
  
삽입정렬(insertion sort) : 두번째  원소부터 시작해서 그 왼쪽의 자료와 비교해 삽입할 위치를 지정 한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬(2번째로 시작해서 그걸 일단 복사 왼쪽꺼랑 비교, 
수행시간 : worstcase : 세타(n^2), average case : 세타(n^2)

고급 정렬 : 평균적으로 Θ(nlogn)의 시간이 소요되는정렬 알고리즘들

병합정렬 : 반을 나눈다 , 각각 독립적으로 정렬한다, 병합한다 (반 나눈거 맨 앞 요소들을 비교  맨앞에 위치, 그다음거랑 다음거랑 비교 계속 비교, 끝날때까지
수행시간 :  Θ(nlogn)
  
퀵정렬 : 분할을 하는데 중간쯤에 기준점을 잡고 비교를 해 앞뒤로 보낸다. 앞뒤를 또 기준점을 정해 앞뒤로 보내 정렬이 완성돌때까지 반복한다.(리스트의 크기가 0이나 1이 될 때까지 반복) 추천하진 않는다...
수행시간 : average case: Θ(nlogn) worst case: Θ(n^2)
  
힙정렬 : 주어진 배열을 힙으로 만든 다음, 차례로 하나씩 힙에서 제거함으로써 정렬한다
힙(Heap) : 특수한 자료구조 사용(완전 이진트리 구조) 일단 힙정렬은 힙구조(완전이진트리구조)가 되어야한다
힙구조(완전이진트리구조) : 트릭구조인데 왼쪽이 가득채워지고 맨밑에 숫자가 위트리보다 크다
힙구조를 배열로 표현
힙정렬 : 힙의 가장 위쪽을 제거 힙구조가 되게 필요없는 부분을 맨위로 옮김 힙구조가 되게 위치를 옮김 또 제거 하고 하나가 남을때까지 반복
수행시간 : worstcase : Θ(nlogn) average case : o(nlogn)

특수한 정렬(O(n)정렬) : 두 원소를 비교하는 것을 기본 연산으로 하는정렬의 하한선은 Ω (nlogn)이다
그러나 원소들이 특수한 성질을 만족하면O(n)정렬도 가능하다 하지만 안정적이진 않음

기수정렬(counting sort 자리수 정렬) :원소들의 크기가 모두 -O(n)~O(n) 범위에 있을 때
가장 낮은 자리수끼리 정렬, 그다음 가장 큰 자리수까지 정렬 반복
수행시간 : O(n)
  
계수정렬( radix sort 위치정렬) 안정적인 정렬 알고리즘이지만 제자리정렬은 아니다
입력 키의 범위만큼 배열을 할당하고입력키의 누적합을 계산하여 정렬하는방법
수행시간 : O(n)

![image](https://github.com/gryrryfh/Algorithm/assets/50912987/b23bfb2d-6f05-49f1-84d4-cb9aa9c11c20)

## 정렬 알고리즘 수도코드
병합정렬
















## 중간고사 나온거
1. 바람직한 알고리즘은?
2. 정렬 설명,
3. 정렬별 시간복잡도
4. 마스터정리로 설명, 추정후증명 설명
5. 퀴즈문제1
6. 시간복잡도 계산
