## 문제
열쇠로 잠긴 독방 N개가 있습니다. 
간수는 위스키를 N잔 마시는데 1잔째 마셨을 때 모든 독방 (N개)의 문을 열어 버립니다.
2잔째를 마셨을 때는 2, 4, 6… 번째 독방에서 A: 문이 잠겨 있으면 열고, B: 문이 열려 있으면 잠급니다.
3잔째를 마시면 3, 6, 9…번째 독방에서 A/B 행동을 합니다. 
4잔째에는 4, 8, 12…번째 독방에서 A/B라는 동작을 N번 반복해서 N잔째를 끝내면 술에 취해 곯아 떨어집니다.
마지막에 남은 문이 열린 독방은 몇 개나 될까요?

## 순서도
![image](https://github.com/gryrryfh/Algorithm/assets/50912987/30bd33e6-c82f-42f5-bed9-68193e749178)

## 코드
```C++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    vector<int> room(N+1, 0);

    for(int i = 1; i <= N; i++) {
        for(int j = i; j <= N; j += i) {
            room[j] = !room[j];
        }
    }

    int open_room = 0;
    
	for(int i = 1; i <= N; ++i) {
		if(room[i]) 
			open_room++;
	}
	
	cout << "열린 방의 수 : " << open_room << "\n";
	
	return 0;
}

```
### 1차 개선
```C++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    vector<int> room(N+1, 0);

    int open_room = 0;

    for(int i = 1; i <= N; i++) {
        for(int j = i; j <= N; j += i) {
            room[j] = !room[j];
        }
        open_room += room[i];
    }

    cout << "열린 방의 수 : " << open_room << "\n";

    return 0;
}

```
벡터초기화 
### 2차 개선
```C++
#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    int open_room = 0;

    for(int i = 1; i <= N; i++) {
        bool room_open = false;
        for(int j = i; j <= N; j += i) {
            room_open = !room_open;
        }
        open_room += room_open;
    }

    cout << "열린 방의 수 : " << open_room << "\n";

    return 0;
}


```
불필요한 벡터 제거
### 3차 개선
```C++
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    int open_room = static_cast<int>(sqrt(N));

    cout << "열린 방의 수 : " << open_room << "\n";

    return 0;
}


```
논리적 성능개선

## 설명
전체 독방 수의 제곱근 정도가 열린 방의 수
