## 문제
열쇠로 잠긴 독방 N개가 있습니다. 
간수는 위스키를 N잔 마시는데 1잔째 마셨을 때 모든 독방 (N개)의 문을 열어 버립니다.
2잔째를 마셨을 때는 2, 4, 6… 번째 독방에서 A: 문이 잠겨 있으면 열고, B: 문이 열려 있으면 잠급니다.
3잔째를 마시면 3, 6, 9…번째 독방에서 A/B 행동을 합니다. 
4잔째에는 4, 8, 12…번째 독방에서 A/B라는 동작을 N번 반복해서 N잔째를 끝내면 술에 취해 곯아 떨어집니다.
마지막에 남은 문이 열린 독방은 몇 개나 될까요?

## 순서도
![image](https://github.com/gryrryfh/Algorithm/assets/50912987/2cfc2da3-3d40-453c-b471-3f95c51f8853)




## 코드
```C++

#include <iostream>
#include <chrono>
#include <vector>
using namespace std;
using namespace chrono;

int main() {
    system_clock::time_point start_time = system_clock::now();
    int N;
    cin >> N;

    vector<int> array(N, 0);  // Initialize a vector of size N with all elements set to 0

    for (int i = 1; i <= N; i++) {
        for (int j = i; j <= N; j += i) {
            array[j - 1] = 1 - array[j - 1];
        }
    }

    for (int i = 0; i < N; i++) {
        if (array[i] == 1) {
            cout << i + 1 << "번째 방은 열려 있습니다." << endl;
        }
        else {
            cout << i + 1 << "번째 방은 잠겨 있습니다." << endl;
        }
    }

    system_clock::time_point end_time = system_clock::now();
    nanoseconds nano = end_time - start_time;
    cout << "걸린 시간: " << nano.count() << "ns" << endl;

    return 0;
}



```
### 1차 개선
```C++
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;
using namespace chrono;
int main() {
    system_clock::time_point start_time = system_clock::now();
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    vector<int> room(N + 1, 0);

    for (int i = 1; i <= N; i++) {
        for (int j = i; j <= N; j += i) {
            room[j] = !room[j];
        }
    }

    int open_room = 0;

    for (int i = 1; i <= N; ++i) {
        if (room[i])
            open_room++;
    }
    system_clock::time_point end_time = system_clock::now();
    nanoseconds nano = end_time - start_time;
    cout << "열린 방의 수 : " << open_room << "\n";

    cout << "걸린시간" << nano.count() << "nanoseconds" << endl;
    return 0;

}


```
벡터초기화 
### 2차 개선
```C++
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;
using namespace chrono;

int main() {
    system_clock::time_point start_time = system_clock::now();
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    vector<int> room(N + 1, 0);

    int open_room = 0;

    for (int i = 1; i <= N; i++) {
        for (int j = i; j <= N; j += i) {
            room[j] = !room[j];
        }
        open_room += room[i];
    }
    system_clock::time_point end_time = system_clock::now();
    nanoseconds nano = end_time - start_time;
    cout << "열린 방의 수 : " << open_room << "\n";
    cout << "걸린 시간 : " << nano.count() << "ns\n";
    return 0;
}
```
불필요한 벡터 제거
### 3차 개선
```C++
#include <iostream>
#include <cmath>
#include <chrono>
using namespace std;
using namespace chrono;

int main() {
    system_clock::time_point start_time = system_clock::now();
    int N;
    cout << "독방의 수 : ";
    cin >> N;

    int open_room = static_cast<int>(sqrt(N));

    cout << "열린 방의 수 : " << open_room << "\n";
    system_clock::time_point end_time = system_clock::now();
    nanoseconds nano = end_time - start_time;
    cout << "걸린 시간 : " << nano.count() << "ns\n";
    return 0;
}

```
논리적 성능개선

## 설명
전체 독방 수의 제곱근 정도가 열린 방의 수
